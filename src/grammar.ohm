Storymatic {
  Script = StatementBlock

  WrappedStatementBlock = "{" Statement* "}"
  StatementBlock = Statement*

  SingleStatementBlock<prefix>
    = WrappedStatementBlock
    | prefix #space Statement -- single_statement

  UnprefixedSingleStatementBlock
    = WrappedStatementBlock
    | Statement -- single_statement

  IfStatement
    = ("if" | "unless") #space Expression SingleStatementBlock<thenOrDo>
      (#space "else" #space (UnprefixedSingleStatementBlock | IfStatement))?

  thenOrDo = "then" | "do"

  SwitchStatement = "switch" #space Expression "{" CaseStatement* DefaultStatement? "}"
  CaseClause = "case" #space Expression CaseTerminator
  CaseStatement = CaseClause+ UnprefixedSingleStatementBlock
  DefaultStatement = "default" #space UnprefixedSingleStatementBlock

  CaseTerminator
    = #colonTerminator -- terminator
    | &"{" -- final

  TryStatement = "try" #space UnprefixedSingleStatementBlock CatchStatement? FinallyStatement?
  CatchStatement = "catch" #space (identifier #space "of" #space)? UnprefixedSingleStatementBlock
  FinallyStatement = "finally" #space UnprefixedSingleStatementBlock

  EnumStatement = ("export" #space)? "enum" #space identifier "{" EnumMember* "}"

  EnumMember
    = (identOrWord | string_non_interpolatable) #expressionTerminator -- auto_assign
    | (identOrWord | string_non_interpolatable) "=" Expression #expressionTerminator -- assigned

  Statement
    = "await" #space (Assignable "=")? Expression SingleStatementBlock<"do"> -- await_new_thread
    | Expression "?"? (#space "of" #space ParameterList)? SingleStatementBlock<"do"> -- when_callback
    | IfStatement
    | TryStatement
    | BlockFunction
    | ClassDeclaration
    | TypeDeclaration
    | InterfaceDeclaration
    | NamespaceDeclaration
    | SwitchStatement
    | EnumStatement
    | "with" #space Expression SingleStatementBlock<"do"> -- with
      // Storymatic's with statement sets the `@` context.
      // It is not associated with JavaScript's `with` statement.
    | "print" #space Expression #statementTerminator -- print
    | "throw" #space Expression #statementTerminator -- throw
    | "repeat" #space Expression SingleStatementBlock<"do"> -- repeat
    | "while" #space Expression SingleStatementBlock<"do"> -- while
    | "until" #space Expression SingleStatementBlock<"do"> -- until
    | "do" #space UnprefixedSingleStatementBlock #space "while" #space Expression #statementTerminator -- do_while
    | "do" #space UnprefixedSingleStatementBlock #space "until" #space Expression #statementTerminator -- do_until
    | "for" #space Assignable #space "in" #space Expression SingleStatementBlock<"do"> -- for_in
    | "for" #space Assignable #space "of" #space Expression SingleStatementBlock<"do"> -- for_of
    | "for" #space "await" #space Assignable #space "of" #space Expression SingleStatementBlock<"do"> -- for_await_of
    | "break" #statementTerminator -- break
    | "continue" #statementTerminator -- continue
    | "return" #space Expression? #statementTerminator -- return
    | "import" #space importLocation #statementTerminator -- empty_import
    | "import" #space NonemptyListOf<ImportableItemName, ","> #space "from" #space importLocation #statementTerminator -- import
    | "import" "*" "as" #space identifier #space "from" #space importLocation #statementTerminator -- import_all
    | "import" "*" identifier #space "from" #space importLocation #statementTerminator -- import_default
    | "export" #statementTerminator -- empty_export
    | "export" #space NonemptyListOf<ExportableItemName, ","> #space "from" #space importLocation #statementTerminator -- export_from
    | "export" "*" "from" #space importLocation #statementTerminator -- export_all_from
    | "export" #space NonemptyListOf<ExportableItemName, ","> #statementTerminator -- export
    | "export" "*" Expression #statementTerminator -- export_default
    | ExportedVariableAssignment #statementTerminator -- export_variable
    | "rescope" #space NonemptyListOf<Rescopable, ","> #statementTerminator -- rescope
    | "rescope" #space VariableAssignment #statementTerminator -- rescope_assign
    | TypedVariableAssignment -- typed_assignment
    | ~("{" "}") Expression #statementTerminator -- expression

  Rescopable
    = identifier ":" Type -- with_type
    | identifier -- identifier

  ClassDeclaration
    = ("export" #space)? "class" #space identifier GenericTypeParameterList?
      (#space "extends" #space (Extendable | Expression))?
      (#space "implements" #space NonemptyListOf<Implementable, ",">)?
      "{" ClassElement* "}"

  ClassElement
    = Method<"@"> -- method
    | Method<"@@"> -- static_method
    | PrivacyLevel ("readonly" #space)?
      "@" MethodName ("!" | "?")? (":" Type)? ("=" Expression)? #statementTerminator -- property
    | PrivacyLevel ("readonly" #space)?
      "@@" MethodName "?"? (":" Type)? ("=" Expression)? #statementTerminator -- static_property
    | IndexSignatureType<"@"> #statementTerminator -- index_signature
    | IndexSignatureType<"@@"> #statementTerminator -- static_index_signature

  importLocation
    = (~(space | "\\" | "\"" | "\'" | statementTerminator) any)+ &statementTerminator -- filename
    | string_non_interpolatable

  ImportableItemName
    = identifier #space "as" #space identifier -- rewrite
    | identifier -- standard

  ExportableItemName
    = identifier #space "as" #space identifier -- rewrite
    | identifier -- standard

  statementTerminator
    = spaces ";" -- semicolon
    | terminator

  expressionTerminator
    = spaces "," -- comma
    | terminator

  typeTerminator
    = spaces "," -- comma
    | spaces ";" -- semicolon
    | terminator

  colonTerminator
    = spaces ":" -- colon
    | terminator

  terminator
    = (spaces &reserved_block | spaces &"}" | spaces end) -- implied
    | lineTerminator

  lineTerminator = whitespace? ("\r\n" | "\n")+ spaces ~lineContinuer
  lineContinuer
    = "+" | "-" | "*" | "/" | "^" | "%" | "==" | "!=" | "[" | "(" | "." | "?." | "?" | ":" | "<" | ">" | "&&" | "||" | "??" | reserved_operators

  Expression = AssignmentExp

  LiteralExp
    = "(" Expression ")" -- parenthesized
    | "[" ListOf<ArrayEntry, #expressionTerminator> ","? "]" -- array
    | "{" ListOf<ObjectEntry, #expressionTerminator> ","? "}" -- object
    | "@" ~(id_continue | "[" | "#" | ".") -- self
    | "@@" ~(id_continue | "[" | "#" | ".") -- static_self
    | "%" -- topic_token
    | "with" #space Expression SingleStatementBlock<"do"> -- with
    | InlineClassDeclaration
    | InlineFunction
    | JSXElement
    | decimalNumber
    | unitNumber
    | hexNumber
    | bigint
    | identifier
    | StaticProperty
    | Property
    | undefined
    | boolean
    | Symbol
    | string_non_interpolatable
    | string
    | null

  InlineClassDeclaration
    = "class" GenericTypeParameterList?
      (#space "extends" #space (Extendable | Expression))?
      (#space "implements" #space NonemptyListOf<Implementable, ",">)?
      "{" ClassElement* "}"

  ArrayEntry
    = Expression
    | "..." Expression -- spread_operator

  InlineFunction
    = "fn" GenericTypeParameterList?
      (#space "of" #space ParameterList)? ("=>" Type)? FunctionBody

  BlockFunction
    = ("export" #space)? "fn" #space identifier GenericTypeParameterList?
      (#space "of" #space ParameterList)? ("=>" Type)? FunctionBody

  Method<prefix>
    = PrivacyLevel "fn" #space prefix MethodName "?"? GenericTypeParameterList?
      (#space "of" #space ParameterList)? ("=>" Type)? FunctionBody

  PrivacyLevel
    = "public" #space -- public
    | "protected" #space -- protected
    | "private" #space -- private
    | -- none

  FunctionBody
    = "return" #space Expression -- expression
    | WrappedStatementBlock

  MethodName
    = identOrWord -- identifier
    | Symbol -- symbol
    | string_non_interpolatable -- string_key
    | string -- computed_string_key
    | decimalNumber -- numerical_key
    | "[" Expression "]" -- computed_key

  ObjectEntry
    = identifier ~":" -- restructure
    | MethodName ":" Expression -- key_value
    | "..." Expression -- spread_operator
    | Method<""> -- object_method
    | Method<"@"> -- object_method_with_self

  MemberAccessExp
    = MemberAccessExp GenericTypeArgumentList "(" ArgumentList ")" -- function_call
    | MemberAccessExp "?" GenericTypeArgumentList "(" ArgumentList ")" -- optional_chaining_function_call
    | MemberAccessExp "?"? ":" identOrWord (GenericTypeArgumentList "(" ArgumentList ")")? -- listen_event
    | MemberAccessExp "?"? "::" identOrWord (GenericTypeArgumentList "(" ArgumentList ")")? -- dispatch_event
    | MemberAccessExpNonCall<MemberAccessExp>

  MemberAccessExpNonCall<Child>
    = Child "." identOrWord -- member_access
    | Child "?." identOrWord -- optional_chaining_member_access
    | Child "." Symbol -- symbol_access
    | Child "?." Symbol -- optional_chaining_symbol_access
    | Child "[" Child "]" -- computed_member_access
    | Child "?" "[" Child "]" -- optional_chaining_computed_member_access
    | Child GenericTypeArgumentList string -- tagged_template_literal
    | Child "!" -- non_null_assertion
    | Child #space "as" #space Type -- as_expression
    | "new" #space NCMemberAccessExp GenericTypeArgumentList "(" ArgumentList ")" -- class_creation_symbolic
    | "new" #space NCMemberAccessExp ~(NonemptyGenericTypeArgumentList | "(") -- class_creation_no_args
    | LiteralExp

  NCMemberAccessExp = MemberAccessExpNonCall<NCMemberAccessExp>

  ArgumentList = ListOf<Argument, #expressionTerminator>
  NonemptyArgumentList = NonemptyListOf<Argument, #expressionTerminator>

  Argument
    = Expression
    | "..." Expression -- spread_operator

  Parameter
    = Assignable (":" Type)? "=" Expression -- initializer
    | Assignable "?"? ":" Type -- type
    | Assignable -- assignable

  RestParameter
    = "..." Assignable ":" Type -- with_type
    | "..." Assignable -- without_type

  ParameterList
    = NonemptyListOf<Parameter, #expressionTerminator> (#expressionTerminator RestParameter)? -- params
    | RestParameter -- rest_params

  NotExp
    = "!" NotExp -- logical_not_symbolic
    | "not" #space NotExp -- logical_not_worded
    | "+" ~digit NotExp -- unary_plus
    | "-" ~digit NotExp -- unary_minus
    | "type" "of" #space NotExp -- typeof
    | "await" #space NotExp -- await
    | MemberAccessExp

  ExpExp
    = ExpExp "^" NotExp -- exponentiate
    | NotExp

  MulExp
    = MulExp "*" ExpExp -- multiplication
    | MulExp "/" ExpExp -- division
    | MulExp "%" ExpExp -- modulus
    | ExpExp

  AddExp
    = AddExp "+" MulExp -- addition
    | AddExp "-" MulExp -- subtraction
    | MulExp

  BitwiseExp
    = BitwiseExp "<<" AddExp -- left_shift
    | BitwiseExp ">>" AddExp -- right_shift
    | BitwiseExp ">>>" AddExp -- unsigned_right_shift
    | AddExp

  CompareExp
    = CompareExp "<" BitwiseExp -- less_than
    | CompareExp "<=" BitwiseExp -- less_than_equal
    | CompareExp ">" BitwiseExp -- greater_than
    | CompareExp ">=" BitwiseExp -- greater_than_equal
    | CompareExp #space ("is" #space)? "in" #space BitwiseExp -- within
    | CompareExp #space "isnt" #space "in" #space BitwiseExp -- not_within
    | CompareExp #space "is" #space ("a" ~(#"n") | "an") #space BitwiseExp -- instanceof
    | CompareExp #space "isnt" #space ("a" ~(#"n") | "an") #space BitwiseExp -- not_instanceof
    | BitwiseExp

  EqualityExp
    = EqualityExp ("==" | #equalityExpWords<"is">) CompareExp -- equal_to
    | EqualityExp ("!=" | #equalityExpWords<"isnt">) CompareExp -- not_equal_to
    | CompareExp

  equalityExpWords<keyword> = #(space+ keyword ~(space+ ("a" ~"n" | "an" | "in")) space+)

  LogicalAndExp
    = LogicalAndExp #(spaces "&&" spaces | space+ "and" space+) EqualityExp -- logical_and
    | EqualityExp

  LogicalOrExp
    = LogicalOrExp #(spaces "||" spaces | space+ "or" space+) LogicalAndExp -- logical_or
    | LogicalOrExp "??" LogicalAndExp -- logical_nullish_coalescing
    | LogicalAndExp

  TernaryExp
    = LogicalOrExp "?" TernaryExp ":" TernaryExp -- symbolic
    | LogicalOrExp

  PipeExp
    = (TernaryExp "|>")+ TernaryExp -- pipe
    | TernaryExp

  AssignmentExp
    = AssignableOrAccessor "=" AssignmentExp -- assignment
    | "yield" #space AssignmentExp -- yield
    | "yield" #space "from" #space AssignmentExp -- yield_from
    | PipeExp

  VariableAssignment = Assignable (":" Type)? "=" Expression
  ExportedVariableAssignment = "export" #space Assignable (":" Type)? "=" Expression
  TypedVariableAssignment = Assignable ":" Type "=" Expression

  AssignableOrAccessor = Accessor | Assignable ~("." | "[")

  AssignableWithDefault
    = Assignable "=" Expression -- with_default
    | Assignable

  AssignableKeyWithRewrite
    = MethodName ":" AssignableWithDefault -- rewrite
    | AssignableWithDefault

  Assignable
    = identifier -- identifier
    | "[" ListOf<AssignableWithDefault, #expressionTerminator>
      (#expressionTerminator "..." Assignable)? ","? "]" -- array
    | "{" ListOf<AssignableKeyWithRewrite, #expressionTerminator>
      (#expressionTerminator "..." Assignable)? ","? "}" -- object

  Accessor
    = AccessorIdentifierBase AccessorAddon+
    | AccessorPropertyBase AccessorAddon*

  AccessorBase = AccessorIdentifierBase | AccessorPropertyBase
  AccessorIdentifierBase = identifier
  AccessorPropertyBase = Property | StaticProperty

  AccessorAddon
    = "." identOrWord -- member_access
    | "." Symbol -- symbol_access
    | "[" Expression "]" -- computed_member_access

  whitespace = (~("\r\n" | "\n") space)+

  sign = ("+" | "-")?
  number = digit+ ("_" digit+)*
  fullNumber = sign number ("." number)? (("e" | "E") sign number)?
  unitNumber = ~"0x" fullNumber ~("n" ~id_continue) identifierWord
  decimalNumber = ~"0x" fullNumber ~char
  hexNumber = sign "0x" hexDigit+ ("_" hexDigit+)*
  bigint = ~"0x" sign number "n"

  boolean = "true" | "false"
  null = "null"
  undefined = "undefined"

  id_continue = alnum | "_"

  string_bit<delimeter>
    = ~("\\" | "{" | delimeter) any -- character
    | "\\" ~("b" | "f" | "n" | "r" | "t" | "u" | "v" | "x" | "0") any -- escape
    | "\\" ("b" | "f" | "n" | "r" | "t" | "v" | ("0" ~digit)) -- escape_sequence
    | "\\x" hexDigit hexDigit -- hex_sequence
    | "\\u" hexDigit hexDigit hexDigit hexDigit -- unicode_sequence
    | "\\u{" hexDigit+ "}" -- unicode_code_point_sequence

  string_interpolatable_head<delimeter> = string_bit<delimeter>*

  string_interpolatable_span<delimeter, interpolated>
    = "{" interpolated "}" string_bit<delimeter>* &(delimeter?)

  string_interpolatable<delimeter, interpolated>
    = delimeter string_interpolatable_head<delimeter>
      "" string_interpolatable_span<delimeter, interpolated>* delimeter

  string_full<delimeter> = delimeter string_bit<delimeter>* delimeter

  string_non_interpolatable = string_full<"\""> | string_full<"'">

  string
    = string_interpolatable<"\"", applySyntactic<Expression>>
    | string_interpolatable<"'", applySyntactic<Expression>>

  string_type
    = string_interpolatable<"\"", applySyntactic<Type>>
    | string_interpolatable<"'", applySyntactic<Type>>

  reserved_block = ("if" | "else" | "then" | "print" | "throw" | "for" | "while" | "until" | "unless" | "do" ~"wn" | "repeat" | "step" | "to" | "through" | "return" | "break" | "continue" | "fn" | "import" | "export" | "class" | "try" | "catch" | "finally" | "switch" | "case" | "default" | "rescope" | "down" | "type" | "interface" | "namespace" | "with") ~id_continue
  reserved_operators = ("and" | "or" | "not" | "is" ~"nt" | "isnt") ~id_continue
  reserved_inline = ("new" | "in" | "type" ~"of" | "of" | "from" | "typeof" | "as" | "extends" | "await") ~id_continue
  reserved_primitive = ("true" | "false" | "null" | "undefined") ~id_continue

  // `super` and `this` are omitted because they are valid names and used often.
  reserved_javascript = ("break" | "case" | "catch" | "class" | "const" | "continue" | "debugger" | "default" | "delete" | "do" | "else" | "enum" | "export" | "extends" | "false" | "finally" | "for" | "function" | "if" | "import" | "in" ~"stanceof" | "instanceof" | "new" | "null" | "return" | /* "super" | */ "switch" | /* "this" | */ "throw" | "true" | "try" | "typeof" | "var" | "void" | "while" | "with" | "implements" | "interface" | "let" | "package" | "private" | "protected" | "public" | "static" | "yield") ~id_continue
  reserved = reserved_block | reserved_operators | reserved_inline | reserved_primitive | reserved_javascript

  char = letter | "_"
  word = char+ (number char*)*
  identifierWord = ~reserved word
  identifierNumber = char* (number char*)+
  identifierWords = identifierWord (whitespace (identifierWord | identifierNumber))*
  identifier = identifierWords
  identOrWord = identifier | word

  Property
    = "@" identOrWord -- identifier
    | "@" Symbol -- symbol
    | "@" "[" Expression "]" -- computed

  StaticProperty
    = "@@" identOrWord -- identifier
    | "@@" Symbol -- symbol
    | "@@" "[" Expression "]" -- computed

  Symbol
    = "#" SymbolKey -- symbol_for
    | "##" SymbolKey -- builtin_symbol

  SymbolKey
    = identOrWord -- name
    | (string_non_interpolatable | string) -- string
    | "[" Expression "]" -- computed

  space += block_comment | line_comment
  block_comment = "/*" (~"*/" any)* "*/"
  line_comment = "//" (~("\r" | "\n") any)* &("\r" | "\n" | end)

  JSXElement
    = "<" JSXTagName GenericTypeArgumentList JSXAttribute* ">" JSXChild* "</" JSXTagName ">" -- open_close
    | "<" JSXTagName GenericTypeArgumentList JSXAttribute* "/" ">" -- self_closing

  jsx_string = (~("<" | "{") any)+

  JSXChild
    = "{" "..."? Expression "}" -- interpolation
    | JSXElement
    | jsx_string

  JSXAttribute
    = JSXAttributeKey ~"=" -- value_true
    | JSXAttributeKey "=" string_non_interpolatable -- value_string
    | JSXAttributeKey "=" string -- value_computed_string
    | JSXAttributeKey "=" "{" "..."? Expression "}" -- value_expression
    | "{" "..." Expression "}" -- spread_attributes

  JSXAttributeKey = word

  JSXTagName
    = JSXTagName "." word -- property_access
    | word -- standard

  Type = ConditionalType

  PrimitiveType
    = "string" | "number" | "boolean" | "true" | "false" | "bigint" | "symbol"
    | "object" | "null" | "undefined" | "void" | "any" | "unknown" | "this"

  Implementable
    = ~("infer" ~(#id_continue)) identifier ("." ~("infer" ~(#id_continue)) identOrWord)* GenericTypeArgumentList &("," | "implements" | "{")

  Extendable
    = ~("infer" ~(#id_continue)) identifier ("." ~("infer" ~(#id_continue)) identOrWord)* NonemptyGenericTypeArgumentList &("," | "implements" | "{")

  QualifiedName = ~("infer" ~(#id_continue)) identifier ("." ~("infer" ~(#id_continue)) identOrWord)*

  LiteralType
    = PrimitiveType ~(id_continue | ".")
    | string_non_interpolatable
    | string_type
    | decimalNumber
    | bigint
    | InlineFunctionType
    | QualifiedName ~"<"
    | QualifiedName NonemptyGenericTypeArgumentList -- type_args
    | "infer" #space identifier (":" #space Type)? -- infer
    | "new" #space InlineFunctionType -- construct
    | "(" Type ")" -- parenthesized

  MemberAccessType
    = MemberAccessType "[" Type "]" -- member_access
    | MemberAccessType "[" "]" -- array
    | "[" ListOf<NamedTupleElement, #expressionTerminator> "]" -- named_tuple
    | "[" ListOf<TupleElement, #expressionTerminator> "]" -- tuple
    | "{" ListOf<TypeObjectEntry, #typeTerminator> "}" -- object
    | LiteralType

  NamedTupleElement
    = identOrWord "?"? ":" Type -- name_value
    | "..." identOrWord ":" Type -- spread_operator

  TupleElement
    = Type "?"? -- value
    | "..." Type -- spread_operator

  TypeObjectKey
    = identOrWord -- identifier
    | string_non_interpolatable -- string
    | decimalNumber -- numerical_key
    | "[" Accessor "]" -- computed_accessor

  TypeObjectEntry
    = ("readonly" #space)? TypeObjectKey "?"? ":" Type -- key_value
    | "new" #space InlineFunctionType -- construct_signature
    | InlineFunctionType -- call_signature
    | IndexSignatureType<"">
    | BlockFunctionType

  InlineFunctionType
    = "fn" GenericTypeParameterList?
      (#space "of" #space TypeParameterList)? "=>" Type

  BlockFunctionType
    = "fn" #space TypeObjectKey "?"? GenericTypeParameterList?
      (#space "of" #space TypeParameterList)? "=>" Type

  IntersectionType = NonemptyListOf<MemberAccessType, "&">
  UnionType = NonemptyListOf<IntersectionType, "|">

  ConditionalType
    = Type #space "is" #space Type "?" Type ":" Type -- conditional
    | UnionType

  NamespaceDeclaration = ("export" #space)? "namespace" #space identifier WrappedStatementBlock

  InterfaceDeclaration
    = ("export" #space)? "interface" #space identifier GenericTypeParameterList?
      (#space "extends" #space NonemptyListOf<Implementable, #expressionTerminator>)?
      "{" ListOf<TypeObjectEntry, #typeTerminator> "}"

  IndexSignatureType<prefix> = "readonly"? prefix "[" identifier ":" Type "]" ":" Type

  TypeDeclaration
    = ("export" #space)? "type" #space identifier GenericTypeParameterList? "=" Type #statementTerminator

  TypeParameter = identifier "?"? ":" Type
  TypeRestParameter = "..." identifier ":" Type

  TypeParameterList
    = NonemptyListOf<TypeParameter, #expressionTerminator> (#expressionTerminator TypeRestParameter)? -- params
    | TypeRestParameter -- rest_params

  GenericTypeParameter = identifier (":" Type)? ("=" Type)?
  GenericTypeParameterList = "<" NonemptyListOf<GenericTypeParameter, #expressionTerminator> ">"

  NonemptyGenericTypeArgumentList = "<" NonemptyListOf<Type, #expressionTerminator> ">"
  GenericTypeArgumentList
    = NonemptyGenericTypeArgumentList -- with_args
    | -- empty

  ListOfTwo<value, sep> = value sep NonemptyListOf<value, sep>
}
